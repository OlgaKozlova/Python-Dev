# День 17 — Области видимости в Python

## 1. Модель областей видимости (LEGB)

Python ищет имена по правилу **LEGB**:

- **L (Local)** — текущая функция
- **E (Enclosing)** — внешние функции (для вложенных функций)
- **G (Global)** — уровень модуля (файла)
- **B (Builtins)** — встроенные имена (`len`, `print`, `sum` и т.д.)

Поиск идёт строго в этом порядке.

Ключевое правило:

> Если внутри функции есть присваивание имени, это имя считается `local` **во всей функции**, независимо от позиции строки.

---

## 2. Отсутствие блочной области видимости

В Python **нет block scope** для `if`, `for`, `while`.

```python
if True:
    x = 10

print(x)  # 10
```

Область создаётся только:

- функцией (`def`)
- модулем (файлом)
- классом (отдельная тема)

Это отличие от JavaScript, где `let` / `const` имеют блочную область.

---

## 3. Типичная ошибка: UnboundLocalError

```python
x = 10

def f():
    x = x + 1
```

Ошибка:

```
UnboundLocalError: local variable 'x' referenced before assignment
```

Причина:

- присваивание делает `x` локальной
- чтение происходит до присваивания
- глобальная `x` игнорируется

---

## 4. Затенение имён (shadowing)

```python
len = 5
len([1, 2, 3])  # TypeError
```

Имя найдено в `Global`, до `Builtins` Python не дошёл.

Вывод:

- не использовать имена встроенных функций
- особенно опасны: `list`, `dict`, `id`, `sum`, `len`

---

## 5. global

`global` указывает, что имя относится к области модуля.

```python
x = 0

def inc():
    global x
    x += 1
```

Особенности:

- не создаёт переменную
- работает только в рамках файла
- используется редко

---

## 6. nonlocal

`nonlocal` используется во вложенных функциях для изменения переменных внешней функции.

```python
def outer():
    x = 0
    def inner():
        nonlocal x
        x += 1
        return x
    return inner
```

Важно:

- ищет имя только в enclosing-областях
- до global не доходит

По умолчанию замыкания в Python **read-only**.
