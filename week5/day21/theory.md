# День 21 — Модули и импорт

## Базовая модель импорта

`import` в Python — это **выполнение кода модуля + привязка имени**.

Алгоритм первого импорта:

1. Поиск файла модуля
2. Выполнение всего кода сверху вниз
3. Создание объекта модуля
4. Кэширование объекта
5. Привязка имени в текущем пространстве имён

Повторный `import` не выполняет код повторно — используется кэш.

## `import module`

- В пространстве имён появляется объект модуля
- Доступ к содержимому через `module.name`
- Предпочтительный вариант для библиотечного кода

## `from module import name`

- Модуль всё равно исполняется целиком
- В текущее пространство имён копируется **ссылка** на объект
- Имя модуля не появляется
- Повышает риск конфликтов имён

## `from module import *`

- Импортируются все публичные имена (`__all__` или всё без `_`)
- Ломает читаемость и анализ кода
- Разрешён только на уровне модуля
- В реальном коде почти не используется

## `__name__` и `__main__`

- При запуске файла напрямую: `__name__ == "__main__"`
- При импорте: `__name__ == имя_модуля`

Стандартный паттерн:

```python
def main():
    ...

if __name__ == "__main__":
    main()
```

Он предотвращает побочные эффекты при импорте.

## Почему Python так устроен (кратко)

- Модуль — объект с состоянием, которое инициализируется выполнением
- API модуля может зависеть от вычислений при загрузке
- Простая и предсказуемая модель важнее ленивой загрузки
