# День 22 — практика (импорты без пакетов)

## Задача 1 — корректная структура

Есть проект:

```
project/
  main.py
  logger.py
  formatter.py
```

Требования:

- запускается только `main.py`
- `formatter` отвечает только за форматирование
- `logger` отвечает только за вывод
- кросс-импортов быть не должно

### Возможное решение

```python
# formatter.py
def format(msg: str) -> str:
    return msg.upper()
```

```python
# logger.py
def log(msg: str) -> None:
    print(msg)
```

```python
# main.py
import formatter
import logger

logger.log(formatter.format("ok"))
```

Комментарий: зависимости однонаправленные, entrypoint один.

---

## Задача 2 — найти архитектурную ошибку

```python
# logger.py
import formatter

def log(msg):
    print(formatter.format(msg))
```

```python
# formatter.py
import logger

def format(msg):
    logger.log("formatting")
    return msg.upper()
```

### Вопрос

Почему это плохой код, даже если он "иногда работает"?

### Разбор

- модули зависят друг от друга напрямую
- при импорте возможна частичная инициализация
- роли перепутаны: форматирование не должно логировать

Исправление — убрать обратную зависимость и логировать на уровне вызывающего кода.

---

## Задача 3 — допустимый `__main__`

```python
# formatter.py
def format(msg):
    return msg.upper()

if __name__ == "__main__":
    print(format("test"))
```

### Вопрос

Почему этот код допустим, но не должен использоваться для запуска сервиса?

### Ответ

- файл запускается как `__main__`, а не как `formatter`
- поведение отличается от импорта в `main.py`
- блок предназначен только для локальной проверки

---

## Самопроверка

Ты усвоила день 22, если можешь:

- объяснить, какой файл является entrypoint
- указать, какие файлы нельзя запускать напрямую
- увидеть архитектурную ошибку в кросс-импорте
- объяснить, зачем нужен `__main__` на этом этапе

---
