# День 29 — Когда ловить исключения, а когда нет

## Ключевая идея

Исключения в Python — механизм обработки **нештатных ситуаций**, а не способ управлять логикой выполнения. `try/except` не заменяет `if`.

---

## Когда исключения **ловить**

Лови исключения, если выполняются **все три условия**:

1. Ошибка **ожидаема** и возможна при нормальной работе программы
   - ввод пользователя
   - чтение файлов
   - сетевые запросы

2. Ты можешь **принять осмысленное решение**:
   - повторить попытку
   - вернуть дефолт
   - сообщить пользователю
   - залогировать и продолжить

3. Ты находишься на **границе системы**:
   - CLI
   - HTTP-хендлер
   - `main`

---

## Когда исключения **не ловить**

Не лови исключения, если:

- ты не знаешь, что с ними делать
- это ошибка программиста, а не среды выполнения
  - `TypeError`
  - `AttributeError`
  - `IndexError`

- используется `except Exception` без причины
- исключение перехватывается слишком рано и теряется контекст

Плохой код:

```python
try:
    do_something()
except Exception:
    pass
```

---

## Уровни ответственности

### Низкий уровень (утилиты)

- делают одну операцию
- не знают, как реагировать
- **не ловят исключения**

```python
def parse_int(value: str) -> int:
    return int(value)
```

### Средний уровень (бизнес-логика)

- добавляет контекст
- может оборачивать исключения

```python
try:
    parse_int(value)
except ValueError as e:
    raise InvalidUserInput(value) from e
```

### Верхний уровень (точка входа)

- **обязан** ловить
- решает, что делать дальше

```python
try:
    run()
except InvalidUserInput:
    print("Ошибка ввода")
```

---

## Конкретные исключения

Плохо:

```python
except Exception:
    ...
```

Хорошо:

```python
except ValueError:
    ...
except OSError:
    ...
```

---

## try / except / else

`else` выполняется **только если исключений не было**.

```python
try:
    value = int(s)
except ValueError:
    return None
else:
    return value * 2
```

Плюс: код успешного сценария не смешан с обработкой ошибок.

---

## finally

Используется для освобождения ресурсов:

- файлы
- блокировки
- соединения

```python
lock.acquire()
try:
    work()
finally:
    lock.release()
```

Если ресурса нет — `finally` не нужен.

---

## Ошибка мышления

❌ «Поймать исключение, чтобы программа не падала»

✅ «Поймать исключение, чтобы **принять решение**»

Если решения нет — пусть исключение поднимается выше.
