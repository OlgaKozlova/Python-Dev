# День 2 — Объекты, ссылки и namespace (конспект)

Этот файл — **сводная теория Дня 2**, собранная после вопросов и разборов. Цель — дать **рабочую ментальную модель Python**, без лишних терминов.

---

## 1. В Python нет «переменных» как ячеек памяти

В Python не существует переменных как контейнеров значений.

Есть:

* **объекты** в памяти
* **имена**, которые на них **ссылаются**

Присваивание:

```python
a = 10
```

Означает:

1. создан объект `int(10)`
2. имя `a` связано с этим объектом

Переприсваивание **не меняет объект**, оно меняет **связь имени**.

Ключевая формула:

> **Имя → ссылка → объект**

---

## 2. Всё в Python — объект

Объектами являются:

* числа, строки, списки
* функции
* классы
* типы (`int`, `list`)
* сам `type`

В Python **нет примитивов** как в C/Java.

---

## 3. Идентичность и равенство

### `==` — равенство значений

```python
a = [1, 2]
b = [1, 2]
a == b  # True
```

### `is` — идентичность объекта

```python
a is b  # False
```

Если:

```python
b = a
a is b  # True
```

→ оба имени указывают на **один объект**.

---

## 4. Изменяемость — свойство объекта

### Immutable объекты

* `int`, `str`, `tuple`
* объект изменить нельзя
* любая «модификация» создаёт **новый объект**

### Mutable объекты

* `list`, `dict`, `set`
* объект можно изменить
* все ссылки видят изменения

---

## 5. Передача аргументов в функции

В Python:

> **В функцию передаётся ссылка на объект**

Функция:

* может изменить объект
* не может изменить связь имени с объектом снаружи

### Пример

```python
def f(x):
    x = 20      # перепривязка имени


def g(lst):
    lst.append(4)  # изменение объекта
```

---

## 6. Перепривязка имени vs мутация объекта

| Код                  | Что меняется |
| -------------------- | ------------ |
| `x = ...`            | имя          |
| `x.append(...)`      | объект       |
| `x[:] = ...`         | объект       |
| `x = x + y`          | новый объект |
| `x += y` (mutable)   | объект       |
| `x += y` (immutable) | новый объект |

### `lst[:] = [...]`

Это **замена содержимого существующего объекта**, а не переприсваивание имени.

---

## 7. `type()`

`type(x)` возвращает **тип объекта**, не тип имени.

```python
type(10) is int
type(int) is type
```

Тип — тоже объект.

---

## 8. Namespace: правильная модель

Реально существуют **3 namespace**:

### 1. Namespace модуля

* каждый файл `.py`
* его «глобальные» имена

### 2. Namespace функции

* локальные имена
* живут только во время вызова функции

### 3. Namespace объекта

* атрибуты (`obj.x`)

Термин **«глобальный namespace»** означает:

> верхний уровень namespace **конкретного модуля**

❗ Нет одного глобального namespace на всю программу.

---

## 9. Поиск имён (LEGB)

Python ищет имя в порядке:

1. **L**ocal — функция
2. **E**nclosing — внешняя функция
3. **G**lobal — namespace модуля
4. **B**uiltins — `len`, `print`, `int`

---

## 10. Финальная рабочая формула

Если держать в голове только это — достаточно:

> **Имена ссылаются на объекты**
> **Функции получают ссылки**
> **Изменяемые объекты меняются, имена — нет**
> **«Глобальный» = уровень модуля**
