# День 3 — Практика по числам и вычислениям (расширенная)

Этот файл предназначен для **самостоятельной проработки числовой модели Python**. Задачи проверяют не знание синтаксиса, а понимание _почему_ код ведёт себя именно так.

---

## Блок A. Выбор числовой модели

### Задача A1

Для каждой ситуации выбери **основной** числовой тип Python (`int`, `float`, `Decimal`, `Fraction`) и обоснуй выбор.

1. Денежные суммы с точностью до копеек. Много операций, результат должен быть воспроизводим.
2. Физическая модель, входные данные — измерения с шумом, важна скорость, допустима погрешность.
3. Работа с точными пропорциями (`2/3`, `5/7`), сравнение без допусков.

Дополнительно:

- укажи, какой тип **не подходит** в каждом случае и почему.

---

## Блок B. `float` и ошибки вычислений

### Задача B1

Объясни результат:

```python
0.1 + 0.2 == 0.3
```

Требования к ответу:

- не использовать фразу «float неточный» без расшифровки;
- указать, на каком этапе возникает ошибка.

---

### Задача B2

Почему выражение даёт `0.0`, а не `1.0`?

```python
1e20 + 1 - 1e20
```

Объяснение должно опираться на понятие **ULP** и масштаб числа.

---

### Задача B3

Объясни результат:

```python
sum([0.1] * 10) == 1.0
```

Укажи:

- порядок выполнения операций;
- роль округления после каждой операции;
- почему используется `==` и к чему это приводит.

---

## Блок C. Деление и остаток

### Задача C1

Найди `q` и `r`:

```python
divmod(-13, 5)
```

Объясни результат через:

- инвариант `a == b*q + r`;
- правило знака остатка в Python.

---

### Задача C2

Сравни модели Python и C:

1. Какой остаток возвращает Python при `-1 % 10`?
2. Почему это поведение удобнее для индексов и циклических структур?

Ответ — словами.

---

## Блок D. `Decimal` и `Fraction`

### Задача D1

Почему `Decimal("0.1") + Decimal("0.2") == Decimal("0.3")`, а `0.1 + 0.2 != 0.3`?

Объясни, **в чём именно различие моделей**, а не просто результат.

---

### Задача D2

Почему при последовательных вычислениях с `Fraction` могут быстро расти числители и знаменатели, даже если дроби сокращаются?

Приведи математическое объяснение.

---

## Блок E. Глобальные числовые функции

### Задача E1 — `round`

Объясни результаты:

```python
round(2.5), round(3.5), round(-2.5), round(-3.5)
```

Почему Python использует именно такое правило?

---

### Задача E2 — `pow`

Почему выражение:

```python
pow(2, 1_000_000, 7)
```

вычисляется быстро и не требует огромной памяти?

Ответ должен быть алгоритмическим, а не «потому что оптимизировано».

---

### Задача E3 — `sum`

Почему `sum` намеренно **не пытается** быть «умным» для `float`?

Какие проблемы это могло бы создать?

---

## Решения и пояснения

### Решение A1

1. **`Decimal`** — точная десятичная модель, управляемое округление, воспроизводимость; `float` не подходит из-за бинарной аппроксимации, `Fraction` избыточен, `int` возможен только при жёстком фиксированном масштабе.
2. **`float`** — высокая скорость, приближённые вычисления допустимы, ошибка измерений превышает ошибку представления.
3. **`Fraction`** — точное представление рациональных чисел без допусков.

---

### Решение B1

`False`.

`0.1` и `0.2` не имеют точного бинарного представления. Складываются приближённые значения, затем результат округляется к ближайшему representable `float`, который не совпадает с представлением `0.3`.

---

### Решение B2

При величине `1e20` минимальный различимый шаг (`ULP`) больше 1, поэтому при сложении `+1` теряется. В результате:

```python
1e20 + 1 == 1e20
```

Дальнейшее вычитание даёт `0.0`.

---

### Решение B3

`False`.

`sum` выполняет линейное сложение слева направо. Каждая операция округляется к `float`, поэтому ошибка представления `0.1` переносится и накапливается. Итоговое значение не совпадает бит-в-бит с `1.0`.

---

### Решение C1

```python
q, r = (-3, 2)
```

Проверка:

```python
-13 == 5 * (-3) + 2
```

Остаток имеет знак делителя и лежит в диапазоне `0 <= r < 5`.

---

### Решение C2

В Python `-1 % 10 == 9`. Это гарантирует, что результат всегда лежит в диапазоне допустимых индексов и упрощает циклические алгоритмы без дополнительных проверок.

---

### Решение D1

`Decimal` хранит числа в десятичной системе без аппроксимации. `float` хранит бинарные дроби, поэтому `0.1` и `0.2` уже приближены до операции сложения.

---

### Решение D2

При сложении рациональных чисел знаменатели перемножаются. Если общих делителей нет, сокращение невозможно, и размер чисел растёт. Это математически неизбежно.

---

### Решение E1

Python использует banker’s rounding (ties-to-even), чтобы устранить систематическое смещение при массовых вычислениях.

---

### Решение E2

Используется алгоритм быстрого возведения в степень по модулю. Промежуточные значения всегда берутся по модулю, рост чисел ограничен, сложность — O(log n).

---

### Решение E3

Любая «умная» стратегия суммирования меняла бы порядок операций и делала бы результат зависимым от реализации, что нарушало бы детерминированность и предсказуемость языка.
