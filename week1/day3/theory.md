# День 3 — Числа и вычисления в Python (расширенный конспект)

Этот файл фиксирует **ментальную модель чисел в Python**, а не только синтаксис. Он рассчитан на повторное чтение без контекста диалога и объясняет _почему_ Python ведёт себя именно так.

---

## 1. Числа как объекты в Python

В Python **все числа — объекты**, а не примитивы.

Следствия:

- число имеет тип (`type(x)`)
- число передаётся по ссылке
- операции над числами — это вызовы методов объектов

Это принципиально отличает Python от языков с примитивными числовыми типами.

---

## 2. `int`: целые числа произвольной точности

### Свойства

- `int` не имеет фиксированной разрядности (не 32 и не 64 бита)
- размер ограничен только доступной памятью
- нет переполнения

```python
10**100  # обычный int
```

### Битовые операции

Операции `& | ^ << >>` работают **над математическим целым**, а не над фиксированным регистром.

Следствия:

- нет «старшего бита»
- `1 << n` корректен для любого `n`
- сдвиги не отбрасывают биты

Отрицательные числа интерпретируются как **бесконечное two’s complement**, что объясняет поведение `>>`.

---

## 3. `float`: бинарные приближённые числа

### Формат хранения

`float` — это IEEE 754 double precision:

- 1 бит знака
- 11 бит экспоненты
- 52 бита мантиссы

Число представляется как:

```
(-1)^sign × mantissa × 2^exponent
```

### Ключевая идея

`float` — **не вещественное число**, а **бинарная дробь конечной точности**.

Большинство десятичных дробей не имеют конечного бинарного представления:

- `0.5` — да
- `0.25` — да
- `0.1` — нет

### Следствия

- `0.1 + 0.2 != 0.3`
- операции неассоциативны
- каждая операция включает округление

---

## 4. ULP и масштаб ошибки

### ULP (Unit in the Last Place)

Минимальный различимый шаг у `float` **зависит от величины числа**.

Приближённая оценка:

```
ULP(x) ≈ |x| × 2^-52
```

Следствия:

- около `1` шаг ~ `2e-16`
- около `1e10` шаг ~ `1e-6`
- около `1e20` шаг ~ `2e4`

Поэтому:

```python
1e20 + 1 == 1e20
```

Малые приращения теряются рядом с большими числами.

---

## 5. Деление и остаток: модель Python

### Операторы

- `/` — всегда возвращает `float`
- `//` — floor-деление
- `%` — остаток, согласованный с `//`

Инвариант Python:

```
a == b*(a // b) + (a % b)
```

При `b > 0` всегда:

```
0 <= a % b < b
```

### Отрицательные числа

Python выбирает **евклидову модель деления**, а не усечение к нулю.

Пример:

```python
divmod(-13, 5)  # (-3, 2)
```

Причины выбора:

- сохранение математических инвариантов
- отсутствие специальных случаев
- безопасность алгоритмов (индексы, циклы)

---

## 6. Приведение типов

### `int(x)`

- выполняет **усечение к нулю**, не округление

```python
int(3.9)   # 3
int(-3.9)  # -3
```

### `float(x)`

- может терять точность
- преобразование несимметрично

```python
int(float(10**50)) != 10**50
```

---

## 7. Ошибки вычислений и сравнение `float`

Причины ошибок:

- приближённое представление
- округление после каждой операции

Сравнение через `==`:

- сравниваются **точные битовые представления**
- допусков нет

Поэтому прямое сравнение `float` почти всегда ошибка проектирования.

---

## 8. `Decimal`: точная десятичная арифметика

### Модель

`Decimal` хранит число как:

```
sign × coefficient × 10^exponent
```

Свойства:

- основание 10
- произвольная точность
- отсутствие скрытой аппроксимации

```python
Decimal("0.1") + Decimal("0.2") == Decimal("0.3")
```

### Контекст

`Decimal` всегда работает в **контексте**:

- точность
- режим округления
- флаги ошибок

Округление — **политика**, а не свойство числа.

`round()` для `Decimal` по смыслу эквивалентен `quantize`.

### Ограничение

`Decimal` не решает проблему иррациональных чисел — только проблему бинарного представления.

---

## 9. `Fraction`: точная рациональная арифметика

### Модель

`Fraction` хранит число как:

```
p / q
```

где `p` и `q` — целые, взаимно простые.

Свойства:

- абсолютная точность
- всегда несократимый вид
- представляет только рациональные числа

### Рост чисел

При операциях:

- знаменатели могут расти как произведения
- сокращение не спасает, если общих делителей нет

Это не баг, а математическая неизбежность.

---

## 10. Рациональные и иррациональные числа

Факты:

- периодическая дробь ⇔ рациональное число
- иррациональные числа имеют бесконечную непериодическую запись

Следствия для Python:

- `Fraction` покрывает ℚ полностью
- `Decimal` покрывает конечные десятичные рациональные
- иррациональные числа возможны только как аппроксимации

---

## 11. Глобальные числовые функции

### `abs(x)`

- вызывает `x.__abs__()`
- если метод не реализован → `TypeError`
- не проверяет тип и знак результата

### `round(x, ndigits=None)`

- для `float` используется banker’s rounding (ties-to-even)
- правило выбрано для устранения систематического смещения
- для `Decimal` зависит от контекста

### `pow(x, y[, mod])`

- `pow(x, y)` ≡ `x ** y`
- `pow(x, y, mod)` — модульное возведение в степень за O(log y)
- использует специализированный алгоритм

### `divmod(a, b)`

- атомарно возвращает `(a // b, a % b)`
- фиксирует евклидову модель деления

### `sum(iterable, start=0)`

- линейное сложение слева направо
- тип и точность определяются `start`
- для `float` может накапливать ошибку

---

## 12. Инженерные выводы

- Выбор числового типа — часть архитектуры
- `float` — для приближённых вычислений
- `Decimal` — для денег и десятичной предметной области
- `Fraction` — для точной рациональной математики
- Модель деления Python выбрана ради инвариантов и безопасности алгоритмов
