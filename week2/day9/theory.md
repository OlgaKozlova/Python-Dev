# День 9 — Паттерны использования словарей

## 1. Словарь как накопитель

Словарь (`dict`) в Python — это отображение ключ → значение. Его основное назначение в прикладном коде — **накопление и агрегация данных**.

Ключевая особенность: словарь работает **по ссылкам**, а не «по значению», и Python не скрывает момент мутации.

---

## 2. Проверка наличия ключей

### Корректно

```python
if key in d:
    value = d[key]
```

### Когда уместен `get`

```python
value = d.get(key, default)
```

`get` — это **безопасный доступ**, а не проверка наличия.

### Антипаттерн

```python
if d.get(key):
    ...
```

Некорректно, если допустимы falsy-значения (`0`, `''`, `False`).

---

## 3. Обновление значений

Классический счётчик:

```python
d[key] = d.get(key, 0) + 1
```

Важно: это **чтение + запись**, не атомарная операция.

---

## 4. Работа с вложенными словарями

Правильная модель:

```python
if user not in result:
    result[user] = {}

result[user][level] = result[user].get(level, 0) + 1
```

Ошибочная модель — путать контейнер и значение:

```python
count = result[user].get(level, 0)
count[level] += 1  # ошибка типов
```

---

## 5. Перебор словаря

### Базовый вариант

```python
for key, value in d.items():
    ...
```

`keys()`, `values()`, `items()` возвращают **view-объекты**, а не списки.

---

## 6. Мутация во время перебора

❌ Нельзя:

```python
for k in d:
    del d[k]
```

✅ Можно:

```python
for k in list(d):
    del d[k]
```

или декларативно:

```python
d = {k: v for k, v in d.items() if condition(k)}
```

---

## 7. Паттерн агрегации

```python
result = {}
for item in data:
    key = item_key(item)
    if key not in result:
        result[key] = []
    result[key].append(item)
```

Это базовый шаблон для:

- группировок
- индексов
- счётчиков
- backend-агрегаций

---

## 8. Почему `dict.get(key, [])` опасен без присваивания

```python
lst = d.get(key, [])
lst.append(x)
```

Если ключа не было — изменения происходят во **временном объекте** и теряются.

Правило:

> Если контейнер получен через `get` с дефолтом — его нужно **явно сохранить**.

---

## 9. Отличие от JavaScript

- Python не смешивает `obj.attr` и `obj['key']`
- `dict` — данные без контракта
- `class` / `dataclass` — данные с формой и поведением

Желание писать `.id` — признак того, что данные пора превращать в модель.
