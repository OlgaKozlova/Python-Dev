# День 7 — Ссылки и копирование (теория)

## 1. Модель Python: объекты и ссылки

В Python переменная **не хранит объект**. Она хранит **ссылку на объект**.

```python
a = [1, 2, 3]
b = a
```

- создаётся **один объект списка**
- `a` и `b` — **две ссылки на один объект**

```python
a is b        # True
id(a) == id(b)  # True
```

Любое изменение через одну ссылку видно через все остальные.

---

## 2. Изменяемые и неизменяемые объекты

**Immutable** (неизменяемые):

- `int`, `float`
- `str`
- `tuple`

**Mutable** (изменяемые):

- `list`
- `dict`
- `set`

```python
x = 10
y = x
y += 1

print(x)  # 10
```

Создаётся новый объект.

```python
x = [1, 2]
y = x
y += [3]

print(x)  # [1, 2, 3]
```

Изменён существующий объект.

---

## 3. Присваивание ≠ копирование

```python
a = [1, 2, 3]
b = a
```

`b` — **не копия**, а новая ссылка.

Если копирование не выполнено явно — его **нет**.

---

## 4. Поверхностное копирование (shallow copy)

Способы:

```python
b = a.copy()
b = list(a)
b = a[:]
```

Создаётся новый контейнер, но **вложенные объекты не копируются**.

```python
a = [[1, 2], [3, 4]]
b = a.copy()

b[0].append(99)
print(a)  # [[1, 2, 99], [3, 4]]
```

---

## 5. Глубокое копирование (`deepcopy`)

```python
import copy

b = copy.deepcopy(a)
```

- рекурсивно копирует всё дерево объектов
- разрывает все ссылки

```python
a[2] is b[2]  # False
```

---

## 6. Почему `deepcopy` нельзя использовать автоматически

- дорог по производительности
- может нарушить логику (там, где объекты должны быть общими)
- скрывает архитектурные ошибки

Инженерное правило:

> Если ты используешь `deepcopy` автоматически — ты не до конца понимаешь структуру данных.

---

## 7. Ключевая фиксация

- Python **ничего не копирует молча**
- Поверхностная копия копирует только контейнер
- Изменения mutable-объектов видны через все ссылки
- Копирование — осознанный выбор, а не «защита от багов»
