# День 15 — Повторение и самопроверка

## Цель дня

Закрепить корректную модель исполнения Python-кода перед переходом к функциям. День не вводит новых конструкций, а проверяет понимание порядка вычислений, работы циклов и comprehension.

---

## Модель выполнения кода

- Код выполняется **строго сверху вниз**.
- Выражения вычисляются в момент, когда интерпретатор до них доходит.
- `print`, вызовы функций и условия — это **выполняемый код**, а не декларации.

---

## Циклы и управление потоком

### `for` / `while`

- Не создают отдельной области видимости.
- Переменная цикла остаётся доступной после выхода из цикла.

### `break` / `continue`

- `break` полностью завершает цикл.
- `continue` переходит к следующей итерации, не выполняя оставшийся код тела.

---

## Comprehension — строгая модель

Общий вид:

```
[EXPR for x in iterable if CONDITION]
```

Эквивалент:

```
for x in iterable:
    if CONDITION:
        result.append(EXPR)
```

Ключевые правила:

1. **В `result` попадает результат `EXPR`, а не `x`.**
2. `CONDITION` вычисляется **для каждого элемента**.
3. Если `CONDITION` — это вызов функции, побочные эффекты выполняются всегда.
4. `EXPR` вычисляется **только если условие истинно**.

---

## Побочные эффекты и `if`

- Функции в `if` внутри comprehension вызываются для каждого элемента.
- Это делает код:
  - трудночитаемым
  - опасным при рефакторинге
  - сложно тестируемым

Рекомендация: если есть побочный эффект — использовать обычный `for`.

---

## Short-circuit логика (`and` / `or`)

- `and` и `or` вычисляются лениво.
- В выражении `x and f(x)`:
  - если `x` ложен → `f(x)` **не вызывается**
  - если `x` истинен → `f(x)` вызывается

Порядок важен:

```
x and f(x)   ≠   f(x) and x
```

---

## Критерий готовности

Ты умеешь:

- мысленно развернуть любой comprehension в обычный `for`
- предсказать количество вызовов функций
- объяснить порядок `print` до запуска кода

Это обязательная база перед темой функций.
