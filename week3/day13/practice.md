# День 13 — Практика

## Задача 1. enumerate vs range(len)

Дан код:

```python
data = ["a", "b", "c"]

for i in range(len(data)):
    print(i, data[i])

for i, v in enumerate(data):
    print(i, v)
```

**Вопросы:**

1. Почему вывод одинаковый?
2. В чём принципиальная разница между этими циклами?
3. Какой вариант устойчивее к рефакторингу и почему?

---

## Задача 2. for-else

```python
nums = [1, 3, 5]

for n in nums:
    if n % 2 == 0:
        print("even")
        break
else:
    print("all odd")
```

**Ответить:**

1. Что будет выведено?
2. Почему?
3. В какой момент принимается решение о выполнении `else`?

---

## Задача 3. Поиск без флага

Перепиши код **без использования флага**:

```python
found = False
for x in data:
    if x == target:
        found = True
        break

if not found:
    print("not found")
```

Используй `for … else`.

---

## Решения

### Задача 1

Оба варианта печатают одинаковый результат, потому что:

- `range(len(data))` вручную управляет индексом
- `enumerate(data)` автоматически добавляет индекс к итерации

Принципиальная разница — `enumerate` не зависит от индексации и работает с любым iterable.

---

### Задача 2

Вывод:

```
all odd
```

Причина:

- ни одно число не чётное
- `break` не был выполнен
- цикл завершился нормально
- поэтому выполняется `else`

Решение о выполнении `else` принимается **после завершения цикла**, при отсутствии `break`.

---

### Задача 3

```python
for x in data:
    if x == target:
        break
else:
    print("not found")
```
