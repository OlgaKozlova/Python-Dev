# День 32 — Методы и атрибуты объектов

## 1. Объект = данные + поведение

Экземпляр класса хранит **только данные**.
Методы лежат в объекте класса.

```python
class User:
    def __init__(self, name):
        self.name = name

    def greet(self):
        return f"Hello, {self.name}"
```

`self.name` — атрибут экземпляра.
`greet` — функция, лежащая в классе.

---

## 2. Связанный метод (bound method)

При обращении:

```python
u.greet
```

Python:

1. Находит функцию в классе
2. Создаёт объект-обёртку (method)
3. Связывает функцию с конкретным экземпляром

Этот объект содержит:

- `__func__` — исходную функцию
- `__self__` — экземпляр

Связывание происходит **в момент доступа**, не вызова.

---

## 3. Поиск атрибутов

При обращении к `u.attr` Python ищет:

1. В `u.__dict__`
2. В `User.__dict__`
3. Далее по MRO

Это похоже на prototype chain в JS.

---

## 4. Атрибуты класса vs экземпляра

```python
class User:
    role = "guest"      # атрибут класса

    def __init__(self, name):
        self.name = name  # атрибут экземпляра
```

- Атрибут класса общий
- Атрибут экземпляра индивидуальный

Если выполнить:

```python
u.role = "admin"
```

создаётся атрибут экземпляра, перекрывающий атрибут класса.

---

## 5. Мутабельные атрибуты класса

```python
class User:
    tags = []
```

Это **один общий список** для всех экземпляров.

- `append()` изменяет объект
- `User.tags = []` заменяет ссылку
- `u.tags = []` создаёт атрибут экземпляра

---

## 6. staticmethod и classmethod

### Обычный метод

Получает `self`.

### @staticmethod

Не получает ни `self`, ни `cls`.
Просто функция в namespace класса.

### @classmethod

Получает `cls` — сам класс.

Используется для:

- альтернативных конструкторов
- работы с атрибутами класса

---

## 7. Полиморфное обращение к классу

```python
type(self).counter += 1
```

Лучше, чем жёсткое указание имени класса.
Позволяет корректно работать при наследовании.

---

## Модель, которую нужно удерживать

- Метод лежит в классе.
- При доступе создаётся bound method.
- Экземпляр хранит только данные.
- Присваивание через экземпляр создаёт новый атрибут.
- Атрибуты класса общие.
- `type(self)` делает код полиморфным.
