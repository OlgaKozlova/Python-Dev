# День 33 — Наследование и переопределение методов

## 1. Базовая модель наследования

Наследование позволяет создать класс на основе другого:

```python
class Animal:
    def speak(self):
        return "..."

class Dog(Animal):
    pass
```

Если метод не найден в Dog, Python ищет его в родительском классе.

Поиск атрибутов идёт по порядку:

1. Экземпляр
2. Класс
3. Родители по MRO

---

## 2. Переопределение (override)

```python
class Dog(Animal):
    def speak(self):
        return "Woof"
```

Подкласс может изменить поведение метода родителя.
Важно сохранять:

- сигнатуру
- смысл метода (контракт)
- тип возвращаемого значения

Нарушение контракта ломает полиморфизм.

---

## 3. super()

`super()` вызывает следующий класс в MRO, а не «конкретного родителя».

Корректное расширение поведения:

```python
class Admin(User):
    def greet(self):
        base = super().greet()
        return f"{base}\nAdmin level: {self.level}"
```

Ошибки:

- не вызвать super().**init** при переопределении конструктора
- использовать print вместо return
- игнорировать возвращаемое значение родителя

---

## 4. Наследование vs добавление новых методов

Подкласс может добавлять новые методы.
Это нормально, если он остаётся корректной подстановкой базового класса (LSP).

---

## 5. Множественное наследование (кратко)

```python
class C(A, B):
    pass
```

Методы ищутся по MRO.
Посмотреть порядок можно через:

```python
C.__mro__
```

Используется в основном для mixin-классов — небольших поведенческих расширений.

---

## Главные выводы

- Наследование — отношение "is-a".
- Override не должен ломать контракт.
- super() — это вызов следующего класса в MRO.
- Множественное наследование применять осторожно, чаще для mixin’ов.
