# День 34 — Композиция vs наследование

## 1. Наследование (is-a)

Наследование означает отношение «является».

```python
class Animal:
    def speak(self):
        raise NotImplementedError

class Dog(Animal):
    def speak(self):
        return "Woof"
```

Dog — это Animal. Он расширяет или переопределяет поведение базового класса.

### Плюсы

- Переиспользование кода
- Полиморфизм

### Минусы

- Жёсткая связность
- Изменения в базовом классе влияют на потомков
- Иерархия может усложняться

---

## 2. Композиция (has-a)

Композиция означает отношение «содержит».

```python
class Engine:
    def start(self):
        return "Engine started"

class Car:
    def __init__(self):
        self.engine = Engine()

    def start(self):
        return self.engine.start()
```

Car не является Engine. Он использует Engine.

### Плюсы

- Слабая связность
- Гибкость
- Лёгкая замена компонентов
- Проще тестировать

---

## 3. Полиморфизм

Полиморфизм — возможность использовать разные объекты через единый интерфейс.

```python
class Cat:
    def speak(self):
        return "Meow"

class Dog:
    def speak(self):
        return "Woof"

animals = [Cat(), Dog()]

for a in animals:
    print(a.speak())
```

Код работает через общий контракт — наличие метода speak.

В Python полиморфизм чаще основан на duck typing: важен не тип, а поведение.

---

## 4. Когда что использовать

Используй наследование, если:

- есть реальная иерархия типов
- требуется общий базовый контракт
- логика действительно общая

Используй композицию, если:

- объект состоит из частей
- поведение может меняться
- нужна гибкость архитектуры

Общее правило: предпочитать композицию, если нет строгой причины для наследования.
